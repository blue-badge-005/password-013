<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Elephant (p5.js)</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
  <style>
    html,body { margin:0; padding:0; background:#f6f7fb; }
    #info { position:fixed; top:10px; left:10px; font:14px/1.4 system-ui, sans-serif; 
            background:#fff; padding:10px 12px; border-radius:12px; box-shadow:0 8px 24px rgba(0,0,0,.08); }
    canvas { display:block; }
  </style>
</head>
<body>
<div id="info">
  <strong>AI Elephant</strong><br/>
  • Wanders & avoids edges<br/>
  • Gets curious and follows your mouse when close<br/>
  • Click to drop a peanut (target)<br/>
</div>

<script>
class Elephant {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = p5.Vector.random2D().mult(1.5);
    this.acc = createVector(0, 0);
    this.maxSpeed = 2.2;
    this.maxForce = 0.08;
    this.state = "wander"; // wander | seek | avoid
    this.target = null; // {pos: p5.Vector, type: 'mouse'|'peanut'}
    this.noiseT = random(1000);
    this.energy = 100; // drifts down when seeking
  }

  update() {
    // Finite-state decisions
    const mouse = createVector(mouseX, mouseY);
    const edgeMargin = 60;

    // Edge avoidance (soft force)
    let edgeForce = createVector(0, 0);
    if (this.pos.x < edgeMargin) edgeForce.x += this.mapEdge(this.pos.x, edgeMargin);
    if (this.pos.x > width - edgeMargin) edgeForce.x -= this.mapEdge(width - this.pos.x, edgeMargin);
    if (this.pos.y < edgeMargin) edgeForce.y += this.mapEdge(this.pos.y, edgeMargin);
    if (this.pos.y > height - edgeMargin) edgeForce.y -= this.mapEdge(height - this.pos.y, edgeMargin);

    // Curiosity: follow mouse if within radius
    const dToMouse = p5.Vector.dist(this.pos, mouse);
    const curiousRadius = 180;

    // Choose state
    if (edgeForce.mag() > 0.2) {
      this.state = "avoid";
      this.applyForce(edgeForce.limit(this.maxForce * 1.5));
    } else if (this.target && this.target.type === "peanut") {
      this.state = "seek";
      this.seek(this.target.pos);
      // Reached peanut
      if (p5.Vector.dist(this.pos, this.target.pos) < 18) {
        this.energy = min(120, this.energy + 25); // "eat" peanut
        this.target = null;
      }
    } else if (dToMouse < curiousRadius && this.energy > 30) {
      this.state = "seek";
      this.target = { pos: mouse.copy(), type: "mouse" };
      this.seek(this.target.pos);
      this.energy -= 0.05;
    } else {
      this.state = "wander";
      this.wander();
      this.energy = min(100, this.energy + 0.02);
      this.target = null;
    }

    // Integrate motion
    this.vel.add(this.acc).limit(this.maxSpeed);
    this.pos.add(this.vel);
    this.acc.mult(0);
  }

  mapEdge(d, margin) {
    // Stronger push the closer to edge
    return map(constrain(d, 0, margin), 0, margin, 0.8, 0.0);
  }

  applyForce(f) {
    this.acc.add(f);
  }

  seek(target) {
    const desired = p5.Vector.sub(target, this.pos).setMag(this.maxSpeed);
    const steer = p5.Vector.sub(desired, this.vel).limit(this.maxForce);
    this.applyForce(steer);
  }

  wander() {
    // Steering via Perlin noise to create gentle, organic motion
    this.noiseT += 0.01;
    const theta = noise(this.noiseT) * TWO_PI * 2;
    const steer = p5.Vector.fromAngle(theta).mult(0.07);
    this.applyForce(steer);
  }

  draw() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.vel.heading() + (this.state === "seek" ? 0 : 0)); // face movement

    // Body
    noStroke();
    fill(120, 130, 145);
    ellipse(0, 0, 90, 70);        // body
    ellipse(30, -20, 50, 45);     // head

    // Ears
    fill(110, 120, 135);
    ellipse(-20, -10, 40, 50);

    // Legs
    fill(95, 105, 120);
    rect(-25, 25, 15, 18, 6);
    rect(-2, 25, 15, 18, 6);
    rect(18, 25, 15, 18, 6);

    // Trunk (aims at direction of travel)
    push();
    const trunkAngle = atan2(this.vel.y, this.vel.x);
    rotate(trunkAngle - (this.vel.heading()));
    fill(110, 120, 135);
    rect(48, -14, 12, 34, 6);
    ellipse(54, 22, 18, 12);
    pop();

    // Eye
    fill(255);
    ellipse(40, -25, 10, 8);
    fill(0);
    ellipse(42, -25, 4, 4);

    // State badge
    pop();
    this.drawStatus();
  }

  drawStatus() {
    push();
    textFont('system-ui'); textSize(12); noStroke(); fill(30, 35, 45);
    textAlign(CENTER, BOTTOM);
    text(`state: ${this.state}`, this.pos.x, this.pos.y - 44);

    // Energy bar
    const w = 60, h = 6;
    rectMode(CENTER);
    fill(230); rect(this.pos.x, this.pos.y - 56, w, h, 4);
    const pct = constrain(this.energy / 120, 0, 1);
    fill(60, 170, 90);
    rect(this.pos.x - w/2 + (w * pct)/2, this.pos.y - 56, w * pct, h, 4);
    pop();
  }
}

let ellie;
let peanuts = [];

function setup() {
  createCanvas(window.innerWidth, window.innerHeight);
  ellie = new Elephant(width * 0.5, height * 0.6);
}

function windowResized() {
  resizeCanvas(window.innerWidth, window.innerHeight);
}

function draw() {
  background(246, 247, 251);

  // Draw peanuts
  noStroke();
  for (const p of peanuts) {
    fill(215, 172, 90);
    ellipse(p.x - 4, p.y, 14, 10);
    ellipse(p.x + 4, p.y, 14, 10);
    fill(190, 150, 75);
    ellipse(p.x - 4, p.y, 6, 4);
    ellipse(p.x + 4, p.y, 6, 4);
  }

  // If there’s a peanut, prefer the closest as target
  if (peanuts.length) {
    let closest = null, minD = Infinity;
    for (const p of peanuts) {
      const d = dist(ellie.pos.x, ellie.pos.y, p.x, p.y);
      if (d < minD) { minD = d; closest = p; }
    }
    ellie.target = { pos: createVector(closest.x, closest.y), type: "peanut" };
    // Remove if eaten (handled in update when very close)
    if (minD < 18) {
      peanuts = peanuts.filter(pp => pp !== closest);
    }
  }

  ellie.update();
  ellie.draw();
}

function mousePressed() {
  // Drop a peanut at click
  peanuts.push({ x: mouseX, y: mouseY });
}
</script>
</body>
</html>
